{"version":3,"sources":["webpack:///./src/apps/HTS/views/encounters/HtsTesting.vue?f8b9","webpack:///./src/apps/HTS/services/hts_testing_service.ts","webpack:///./src/apps/HTS/views/encounters/HtsTesting.vue","webpack:///./src/apps/HTS/views/encounters/HtsTesting.vue?86a7","webpack:///./src/components/Forms/HisStandardForm.vue?8e31","webpack:///./src/components/Forms/HisStandardForm.vue","webpack:///./src/components/Forms/HisStandardForm.vue?5176","webpack:///./src/apps/HTS/composables/testKits.ts"],"names":["render","_ctx","_cache","$props","$setup","$data","$options","_component_his_standard_form","_resolveComponent","_component_ion_page","_openBlock","_createBlock","default","_withCtx","_createVNode","formLabel","fields","onFinishAction","onFinish","cancelDestinationPath","patientDashboardUrl","_","HtsTestingService","AppEncounterService","constructor","patientID","providerID","super","getRecentAccesspoint","this","getFirstValueCoded","defineComponent","components","IonPage","HisStandardForm","setup","ref","service","htsClient","toOption","saveEncounter","toYesNoOption","mapStrToOptions","toConditionalOptions","StartHtsEncounter","onInitVisit","value","accessPointTypeField","facilityAccessPointField","communityAccessPoints","testsOfferedField","lastHivTestResultField","lastHivTestTypeField","lastTimeHIVTestedField","arvHistoryField","drugTakenField","mostRecentDrugHiddenField","timeSinceDrugTaken","clientRiskCategoryField","testResultsField","hivTestKitDetailsField","hivResultHiddenField","hivPatientCategoryField","computedData","encounterName","encounterTypeID","threeTierHIVtestNotComplete","testingFieldData","testOnePositive","isIncompleteThreeTier","opt","_opt$other","other","id","test","disabled","validateTimeUnit","v","maxDaysAllowed","maxWeeksAllowed","maxMonthsAllowed","parseInt","timeUnit","length","Date","date","birthDate","label","age","inclonclusiveResultDialog","infoActionSheet","name","slot","testOffered","formData","tests_offered","some","helpText","type","FieldType","TT_SELECT","isRequired","finalComputedValue","concept","offlineMeta","obs","buildValueCoded","options","TT_SELECT_GRID","condition","f","accesspoint_type","buildValueText","config","columnsPerRow","availableTests","TT_MULTIPLE_SELECT","init","async","getUserProp","UserProp","res","tests","split","filter","prop","map","replace","trim","e","console","error","defaultOutput","buildOptionsOnce","includes","last_hiv_result","TT_AGE_INPUT","beforeNext","monthsAgoInt","color","validation","buildObs","excludeUnits","TT_MULTIPLE_YES_NO","d","last_taken_drugs","_f$last_hiv_result","drugCount","drug","artSelected","find","TT_HIDDEN","defaultValue","fdata","value_text","value_datetime","TT_INPUT_ARRAY","test_results","t","expiryDate","lotNo","columns","summaryMapValue","data","someIncomplete","count","x","incomplete","parentObs","childObs","l","child","Promise","all","kits","r","every","buildValueDate","testResults","Array","isArray","kitNameOption","kitName","clearable","usefontBold","kitLotNoOption","onclick","val","keyboard","TT_TEXT","kitExpiryDateOption","TT_FULL_DATE","toDate","enteredKits","test_kit","existingOption","shortName","getLotNo","getExpiryDate","initKits","TestKit","isStatus","status","requireAllValues","resultMap","isInconclusive","isPositive","alertConfirmation","header","onValueUpdate","results","testOneIsPositive","testTwoIsPositive","disable","forEach","_d$other","reduce","a","c","option","params","category","undefined","accessPoint","values","resultModel","KitProp","DETERMINE","UNIGOLD","BIOLINE","SYPHILIS","HEPATITIS","prevResults","defaultOption","existingResult","push","concat","result","appearInSummary","onload","hasLastTestPerfomed","last_hiv_perfomed","hasLastHivResult","testOneResult","testTwoResult","testThreeResult","testOneRepeat","isCommunity","lastHIVResult","_f$last_hiv_result2","lastTestPerfomed","_f$last_hiv_perfomed","inconclusiveNegativeForPreviousPositiveProfessional","Incomplete","Negative","Positive","Inconclusive","Positive Initial Professional","Object","keys","finalResult","key","Boolean","hivStatusCategory","hiv_result","newHivStatus","clientAge","lastHivResult","lastTypeOfTestPerformed","lastTimeHivTestedInMonths","last_time_hiv_tested","hivCategoryRef","__exports__","_resolveDynamicComponent","formType","skipSummary","activeField","onOnFinish","onOnIndex","onIndex","TouchScreenForm","emits","props","Function","String","required","methods","$emit","i","setUserProp","getSelectedTests","req","defaultKits","testGroup","visible","userProp","HIV_SELF_KIT","selectedKits","TEST_KIT_USER_PROPERTY","prevKits","JSON","parse","kit","isEmpty","preset","k","Service","getSessionDate","saveKits","stringify"],"mappings":"yIAEM,SAAUA,EAAOC,EAAUC,EAAYC,EAAYC,EAAYC,EAAWC,GAC9E,MAAMC,EAA+BC,8BAAkB,qBACjDC,EAAsBD,8BAAkB,YAE9C,OAAQE,yBAAcC,yBAAaF,EAAqB,KAAM,CAC5DG,QAASC,qBAAS,IAAM,CACtBC,yBAAaP,EAA8B,CACzCQ,UAAW,UACXC,OAAQf,EAAKe,OACbC,eAAgBhB,EAAKiB,SACrBC,sBAAuBlB,EAAKmB,uBAC3B,KAAM,EAAG,CAAC,SAAU,iBAAkB,4BAE3CC,EAAG,I,4DCbD,MAAOC,UAA0BC,OACnCC,YAAYC,EAAmBC,GAAa,GACxCC,MAAMF,EAAW,IAAKC,GAG1BE,uBACI,OAAOC,KAAKC,mBAAmB,oB,gHCQxBC,+BAAgB,CAC7BC,WAAY,CAAEC,eAASC,wBACvBC,QACE,MAAMnB,EAASoB,iBAAa,IACtBC,EAAU,IAAIf,GAAmB,IACjC,UACJgB,EAAS,SACTC,EAAQ,cACRC,EAAa,cACbC,EAAa,gBACbC,EAAe,oBACftB,EAAmB,qBACnBuB,GACGC,eAAkB,CACrBC,YAAaA,KACX7B,EAAO8B,MAAQ,CACbC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,IACAC,QAKN,SAAS5C,EAASG,EAAQ0C,GACxBvB,EAAc,CACZwB,cAAe,UACfC,gBAAiB5B,EAAQ4B,gBACzBF,iBAWJ,SAASG,EAA4BC,GACnC,IAAIC,GAAkB,EAClBC,GAAwB,EAC5B,IAAK,MAAMC,KAAOH,EAAkB,KAAAI,EACb,WAAjBD,EAAIE,MAAMC,IAAiC,aAAdH,EAAIxB,MACnCsB,GAAkB,EAElB,+BAA+BM,KAAK,IAAM,OAAHJ,QAAG,IAAHA,GAAU,QAAPC,EAAHD,EAAKE,aAAK,IAAAD,OAAA,EAAVA,EAAYE,MACrC,KAAdH,EAAIxB,QAAiBwB,EAAIK,WAEzBN,GAAwB,GAG5B,OAAOD,GAAmBC,EAG5B,SAASO,EAAiBC,GACxB,MAAMC,EAAiB,GACjBC,EAAkB,GAClBC,EAAmB,GAEzB,OAAIC,SAAS,GAAGJ,EAAEL,MAAM1B,QAAY,IAAM,OAAO4B,KAAKG,EAAEL,MAAMU,UACrD,CAAC,SAASL,EAAEL,MAAMU,8BAEH,SAArBL,EAAEL,MAAMU,UAAuBD,SAAS,GAAGJ,EAAEL,MAAM1B,OAAWgC,EACxD,CAAC,SAASD,EAAEL,MAAMU,sBAAsBJ,wBAEzB,UAArBD,EAAEL,MAAMU,UAAwBD,SAAS,GAAGJ,EAAEL,MAAM1B,OAAWiC,EACzD,CAAC,SAASF,EAAEL,MAAMU,sBAAsBH,yBAEzB,WAArBF,EAAEL,MAAMU,UAAyBD,SAAS,GAAGJ,EAAEL,MAAM1B,OAAWkC,EAC1D,CAAC,SAASH,EAAEL,MAAMU,sBAAsBF,wBAE7CH,EAAEL,MAAM1B,MAAMqC,OAAS,GAA0B,MAArBN,EAAEL,MAAM1B,MAAM,GACrC,CAAC,SAAS+B,EAAEL,MAAM1B,qBAEvB,IAAIsC,KAAKP,EAAEL,MAAMa,MAAQ,IAAID,KAAK9C,EAAUgD,WACvC,CACL,GACET,EAAEU,yCACgCjD,EAAUkD,aAG3C,KAGT,SAASC,IACP,OAAOC,eACL,kBACA,GACA,+DACA,CAAC,CAAEC,KAAM,KAAMC,KAAM,WAIzB,SAASC,EAAYC,EAAepB,GAClC,OAAOoB,EAASC,cAAcC,KAAMnB,GAAcA,EAAE/B,QAAU4B,GAGhE,SAAS3B,IACP,MAAO,CACL0B,GAAI,mBACJwB,SAAU,oBACVC,KAAMC,OAAUC,UAChBC,WAAYA,KAAM,EAClBC,mBAAqBzB,IACnB,MAAM0B,EAAU,kBAChB,MAAO,CACLC,YAAa,CACX,CAACD,GAAW1B,EAAE/B,OAEhB2D,IAAKpE,EAAQqE,gBAAgBH,EAAS1B,EAAE/B,SAG5C6D,QAASA,IACA,CACL,CAAEpB,MAAM,kBAAmBzC,MAAM,mBACjC,CAAEyC,MAAO,YAAazC,MAAO,aAC7B,CAAEyC,MAAO,mCAAoCzC,MAAO,qBAM5D,SAASE,IACP,MAAO,CACLyB,GAAI,yBACJwB,SAAU,gCACVC,KAAMC,OAAUS,eAChBP,WAAYA,KAAM,EAClBQ,UAAYC,GAAwC,oBAA7BA,EAAEC,iBAAiBjE,MAC1CwD,mBAAqBzB,IACZ,CACL4B,IAAKpE,EAAQ2E,eACX,iCACA,GAAGnC,EAAE/B,SAIXmE,OAAQ,CACNC,cAAe,GAEjBP,QAASA,IACA,CACL,CAACpB,MAAO,UAAWzC,MAAO,OAC1B,CAACyC,MAAO,UAAWzC,MAAO,mBAC1B,CAACyC,MAAO,gBAAiBzC,MAAO,aAChC,CAACyC,MAAO,UAAWzC,MAAO,OAC1B,CAACyC,MAAO,mDAAoDzC,MAAO,aACnE,CAACyC,MAAO,YAAazC,MAAO,SAC5B,CAACyC,MAAO,iBAAkBzC,MAAO,cACjC,CAACyC,MAAO,WAAYzC,MAAO,QAC3B,CAACyC,MAAO,mBAAoBzC,MAAO,gBACnC,CAACyC,MAAO,UAAWzC,MAAO,MAC1B,CAACyC,MAAO,WAAYzC,MAAO,OAC3B,CAACyC,MAAO,uCAAwCzC,MAAO,SACvD,CAACyC,MAAO,uCAAwCzC,MAAO,SAM/D,SAASG,IACP,MAAO,CACLwB,GAAI,0BACJwB,SAAU,0BACVC,KAAMC,OAAUC,UAChBS,UAAYC,GAAwC,cAA7BA,EAAEC,iBAAiBjE,MAC1CuD,WAAYA,KAAM,EAClBC,mBAAqBzB,IACZ,CACL4B,IAAKpE,EAAQ2E,eACX,iCACA,GAAGnC,EAAE/B,SAIX6D,QAASA,IACA,CACL,CAACpB,MAAO,WAAYzC,MAAO,OAC3B,CAACyC,MAAO,aAAczC,MAAO,SAC7B,CAACyC,MAAO,YAAazC,MAAO,QAC5B,CAACyC,MAAO,aAAczC,MAAO,SAC7B,CAACyC,MAAO,WAAYzC,MAAO,OAC3B,CAACyC,MAAO,cAAezC,MAAO,YAMtC,SAASI,IACP,IAAIiE,EAA2B,CAC7B,MACA,WACA,eAEF,MAAO,CACL1C,GAAI,gBACJwB,SAAU,6BACVC,KAAMC,OAAUiB,mBAChBC,KAAMC,UACJ,IACE,MAAM,YAAEC,GAAgBC,iBAClBC,QAAYF,EAAY,gBACxBG,EAAQD,EAAIE,MAAM,KAAKC,OAC1BC,GAAiB,0BAA0BnD,KAAKmD,IACjDC,IAAKpD,GAAiBA,EAAKqD,QAAQ,QAAS,IAAIC,QAC9CN,EAAMvC,QAAU,IAAGgC,EAAiBO,GACxC,MAAOO,GAEP,OADAC,QAAQC,MAAMF,IACP,EAET,OAAO,GAET5B,WAAYA,KAAM,EAClBQ,UAAWA,IAAMM,EAAehC,OAAS,EACzCiD,cAAeA,IAAM1F,EAAgByE,GACrCR,QAASA,IAAMjE,EAAgByE,GAC/BF,OAAQ,CACNoB,kBAAkB,IAKxB,SAASlF,IACP,MAAO,CACLsB,GAAI,kBACJwB,SAAU,gBACVC,KAAMC,OAAUC,UAChBC,WAAYA,KAAM,EAClBC,mBAAqBzB,IACnB,MAAM0B,EAAW,4BACjB,MAAO,CACLC,YAAa,CACX,CAACD,GAAU1B,EAAE/B,OAEf2D,IAAKpE,EAAQqE,gBAAgBH,EAAS1B,EAAE/B,SAG5C6D,QAASA,IACAhE,EAAqB,CAC1B,CAAC,gBACD,CAAC,YACD,CAAC,YACD,CAAC,kBACD,CAAC,8BAMT,SAASS,IACP,MAAO,CACLqB,GAAI,oBACJwB,SAAU,0BACVC,KAAMC,OAAUC,UAChBC,WAAYA,KAAM,EAClBQ,UAAYC,IACT,CAAC,eAAgB,kBAAkBwB,SAASxB,EAAEyB,gBAAgBzF,OACjEwD,mBAAqBzB,IACnB,MAAM0B,EAAU,yBAChB,MAAO,CACLC,YAAa,CACX,CAACD,GAAU1B,EAAE/B,OAEf2D,IAAKpE,EAAQqE,gBAAgBH,EAAS1B,EAAE/B,SAG5CsF,cAAgBtB,IACd,GAAI,kBAAkBpC,KAAKoC,EAAEyB,gBAAgBzF,OAC3C,OAAOP,EAAS,iBAGpBoE,QAAUG,GACDnE,EAAqB,CAC1B,CAAC,QACD,CACE,wBACC,yBAAyB+B,KAAKoC,EAAEyB,gBAAgBzF,QAEnD,CAAC,mBAMT,SAASO,IACP,MAAO,CACLoB,GAAI,uBACJwB,SAAU,2BACVC,KAAMC,OAAUqC,aAChB3B,UAAYC,GACVA,EAAEyB,gBAAgBzF,OAAoC,gBAA3BgE,EAAEyB,gBAAgBzF,MAC/CuD,WAAYA,KAAM,EAClBoC,WAAYnB,MAAOzC,EAAWiC,KACxBjC,EAAEL,MAAMkE,cAAgB,KAAO7C,EAAYiB,EAAG,cAC1CpB,eACJ,uBACA,GACA,yCACA,CACE,CACEC,KAAM,KACNC,KAAM,QACN+C,MAAO,cAKR,GAETC,WAAa/D,GAAcD,EAAiBC,GAC5CyB,mBAAqBzB,IACnB,MAAM0B,EAAU,mBAChB,MAAO,CACLC,YAAa,CACX,CAACD,GAAU1B,EAAE/B,OAEf2D,IAAKpE,EAAQwG,SAAStC,EAAS,CAC7B,eAAkB1B,EAAEL,MAAMa,KAC1B,WAAcR,EAAE/B,UAItBmE,OAAQ,CACN6B,aAAc,CAAC,WAKrB,SAASxF,IACP,MAAO,CACLmB,GAAI,mBACJwB,SAAU,kCACVC,KAAMC,OAAU4C,mBAChB1C,WAAYA,KAAM,EAClBC,mBAAqBzB,IACZ,CACL4B,IAAK5B,EAAEiD,IAAKkB,GACV3G,EAAQqE,gBAAgBsC,EAAExE,MAAM+B,QAASyC,EAAElG,UAIjD6D,QAAUG,GACJA,EAAEmC,iBAAyBnC,EAAEmC,iBAC1B,CACLxG,EAAc,qBAAsB,CAClC8D,QAAS,yBAER,CAAC2C,GACE,IAAoB,QAApBA,EAAGpC,EAAEyB,uBAAe,IAAAW,OAAA,EAAjBA,EAAmBpG,QAAW,WAC5B,CAACL,EAAc,MAAO,CAAE8D,QAAS,sBAEnC,GAJN,GAMH9D,EAAc,MAAO,CAAE8D,QAAS,uBAMxC,SAAShD,IAIP,MAAO,CACLkB,GAAI,aACJwB,SAAU,yBACVC,KAAMC,OAAUC,UAChBC,WAAYA,KAAM,EAClBQ,UAAYC,IACV,IAAIqC,EAAY,EAChB,IAAI,MAAMC,KAAQtC,EAAEmC,iBAAkB,CACpC,GAAmB,QAAfG,EAAK7D,OAAkC,QAAf6D,EAAKtG,MAC/B,OAAO,EAEU,QAAfsG,EAAKtG,SAAmBqG,EAE9B,OAAOA,EAAY,GAErBf,cAAgBtB,IACd,MAAMuC,EAAcvC,EAAEmC,iBAAiBK,KAAMN,GAA0B,QAAZA,EAAEzD,OAC7D,GAA2B,SAAZ,OAAX8D,QAAW,IAAXA,OAAW,EAAXA,EAAavG,OACf,OAAOP,EAAS,QAGpB+D,mBAAqBzB,IACnB,MAAM0B,EAAU,yBAChB,MAAO,CACLC,YAAa,CACX,CAACD,GAAU1B,EAAE/B,OAEf2D,IAAKpE,EAAQqE,gBAAgBH,EAAS1B,EAAE/B,SAG5C6D,QAAUG,GACDA,EAAEmC,iBACNrB,OAAQoB,GAA0B,QAAZA,EAAElG,OACxBgF,IAAKkB,GAAczG,EAASyG,EAAEzD,SAKvC,SAAS/B,IAIP,MAAO,CACLiB,GAAI,mBACJwB,SAAU,mBACVC,KAAMC,OAAUoD,UAChB1C,UAAYC,GAEV,IADAA,EAAEmC,iBAAiBrB,OAAQoB,GAA0B,QAAZA,EAAElG,OAAiBqC,OAE9DqE,aAAeC,GACNH,kBAAKG,EAAMR,iBAAkB,CAAEnG,MAAO,QAE/CwD,mBAAqBzB,IACZ,CACL4B,IAAKpE,EAAQqE,gBACX,yBACA7B,EAAE/B,UAOZ,SAASW,IACP,MAAO,CACLgB,GAAI,6BACJwB,SAAU,mCACVC,KAAMC,OAAUqC,aAChB3B,UAAYC,GACVA,EAAEmC,iBAAiBjD,KAAMgD,GAA0B,QAAZA,EAAElG,OAC3CwD,mBAAqBzB,IACnB,MAAM0B,EAAU,mCAChB,MAAO,CACLC,YAAa,CACX,CAACD,GAAU1B,EAAE/B,OAEf2D,IAAKpE,EAAQwG,SAAStC,EAAS,CAC7BmD,WAAe7E,EAAE/B,MAAL,OACZ6G,eAAgB9E,EAAEL,MAAMa,SAI9BuD,WAAa/D,GAAcD,EAAiBC,GAC5CwB,WAAYA,KAAM,EAClBY,OAAQ,CACN6B,aAAc,CAAC,WAKrB,SAASpF,IACP,MAAO,CACLe,GAAI,uBACJwB,SAAU,uBACVC,KAAMC,OAAUC,UAChBC,WAAYA,KAAM,EAClBC,mBAAqBzB,IACnB,MAAM0B,EAAU,uBAChB,MAAO,CACLC,YAAa,CAAE,CAACD,GAAU1B,EAAE/B,OAC5B2D,IAAKpE,EAAQqE,gBAAgBH,EAAS1B,EAAE/B,SAG5C6D,QAASA,IACAjE,EAAgB,CACrB,WACA,gBACA,mCACA,8BAMR,SAASkB,IACP,MAAO,CACLa,GAAI,WACJwB,SAAU,kBACVC,KAAMC,OAAUyD,eAChB/C,UAAYC,GAAWA,EAAE+C,aAAajC,OAAQkC,GAAuB,IAATA,EAAEhH,OAC3DkD,KAAM8D,KAAgBA,EAAEtF,MAAMuF,YAAcD,EAAEtF,MAAMwF,QACvD/C,OAAQ,CACNgD,QAAS,CACP,CAAE1E,MAAO,YACT,CAAEA,MAAO,eACT,CAAEA,MAAO,qBAGb2E,gBAAkBrF,IACT,CACLU,MAAO,QAAQV,EAAEU,MACjBzC,MAAO,YAAW+B,EAAE/B,OAAS+B,EAAEL,MAAMxD,OAAO,GAAG8B,SAGnD8F,WAAa/D,IACX,MAAMsF,EAAOtF,EAAEiD,IAAKkB,GAAcA,EAAExE,MAAMxD,QACpCoJ,EAAiBD,EAAKnE,KAAMgD,IAChC,MAAMqB,EAAQrB,EAAEpB,OAAQ0C,GAAyB,IAAXA,EAAExH,OAAaqC,OACrD,OAAOkF,EAAQ,GAAKA,EAAQ,IAE9B,GAAID,EACF,MAAO,CAAC,mCAEV,MAAMG,EAAaJ,EAAKnE,KAAMgD,GACrBA,EAAEhD,KAAMsE,GAA0B,KAAZA,EAAExH,QAEjC,OAAIyH,EACK,CAAC,8BAEH,MAETjE,mBAAqBzB,IACZ,CACL4B,IAAK5B,EACFiD,IAAKkB,GAAMA,EAAExE,MAAMxD,QACnB8G,IAAIR,UACH,MAAOkD,KAAcC,GAAY9D,EAC9BiB,OAAQ8C,GAAqC,oBAAhBA,EAAElG,MAAMiC,KACrCqB,IAAKkB,GAAcA,EAAExE,MAAMiC,IAAIuC,IAClC,MAAO,UACKwB,EACVG,YAAaC,QAAQC,IAAIJ,QAKnCrC,cAAgBtB,IACd,MAAMgE,EAAOhE,EAAE+C,aAAajC,OAAQmD,GAAuB,IAATA,EAAEjI,OACpD,GAAIgI,EAAKE,MAAOlB,GAAcA,EAAEtF,MAAMuF,YAAcD,EAAEtF,MAAMwF,OAC1D,OAAOc,EAAKhD,IAAKjD,IACR,CACLU,MAAOV,EAAEU,MACTzC,MAAO+B,EAAEL,MAAMwF,MACfxF,MAAO,CACLxD,OAAQ,CACN,CACEuE,MAAO,WACPzC,MAAO+B,EAAEU,MACTf,MAAO,CACLiC,IAAKA,IAAMpE,EAAQ2E,eAAe,WAAYnC,EAAEU,SAGpD,CACEA,MAAO,aACPzC,MAAO+B,EAAEL,MAAMwF,MACfxF,MAAO,CACLiC,IAAKA,IACIpE,EAAQ2E,eAAe,iBAAkBnC,EAAEL,MAAMwF,SAI9D,CACEzE,MAAO,kBACPzC,MAAO+B,EAAEL,MAAMuF,WACfvF,MAAO,CACLiC,IAAKA,IAAMpE,EAAQ4I,eAAe,kBAAmBpG,EAAEL,MAAMuF,oBAS7EpD,QAASW,UACP,MAAM4D,EAAwBC,MAAMC,QAAQtE,EAAE+C,cAAgB/C,EAAE+C,aAAe,GACzEwB,EAAiBC,IAAe,CACpC/F,MAAO,WACPzC,MAAOwI,EACPC,WAAW,EACX/G,MAAO,CACLgH,aAAa,EACb/E,IAAM5B,GAAcxC,EAAQ2E,eAAe,WAAYnC,EAAEU,UAGvDkG,EAAkBzB,IAAa,CACnCzE,MAAO,cACPzC,MAAOkH,EACPxF,MAAO,CACLiC,IAAM5B,GACJxC,EAAQ2E,eAAe,iBAAkBnC,EAAE/B,OAC7C4I,QAAUC,IACRC,eAAS,CACPnH,GAAI,MACJwB,SAAU,mBACVC,KAAMC,OAAU0F,QAChBxF,WAAYA,KAAM,GAEnBxB,IACC8G,EAAI7I,MAAQ+B,EAAE/B,YAKhBgJ,EAAuB/B,IAAkB,CAC7CxE,MAAO,kBACPzC,MAAOiH,EACPvF,MAAO,CACLiC,IAAM5B,GACJxC,EAAQ4I,eAAe,kBAAmBpG,EAAE/B,OAC9C4I,QAAUC,IACRC,eACE,CACEnH,GAAI,WACJwB,SAAU,kBACVC,KAAMC,OAAU4F,aAChB1F,WAAYA,KAAM,EAClBuC,WAAa/D,GACP,IAAIO,KAAKP,EAAEU,OAAS,IAAIH,KAAK/C,EAAQgD,MAChC,CACL,gDACE2G,eAAO3J,EAAQgD,OAGd,MAGVR,IACC8G,EAAI7I,MAAQ+B,EAAE/B,YAMlBmJ,EAA6B,OAAfnF,EAAEoF,SAAoB,GAAKpF,EAAEoF,SACjD,OAAOhB,EACJtD,OAAQkC,GAAiB,IAAXA,EAAEhH,OAChBgF,IAAKgC,IACJ,MAAMqC,EAAiB7C,kBAAK2C,EAAa,CAAE1G,MAAOuE,EAAEvE,QACpD,OAAI4G,GACG,CACL5G,MAAOuE,EAAEvE,MACTzC,MAAO,GACP0B,MAAO,CACLxD,OAAQ,CACNqK,EAAcvB,EAAEtF,MAAM4H,WACtBX,EAAe3B,EAAEtF,MAAMwF,OACvB8B,EAAoBhC,EAAEtF,MAAMuF,mBAS5C,SAASpG,IACP,MAAM,SAAE0I,EAAQ,cAAEC,EAAa,SAAEC,GAAaC,iBACxCC,EAAWA,CAAC/B,EAAahG,EAAcgI,MAC3CpD,kBAAKoB,EAAG,CACN5H,MAAO4J,EACPlI,MAAO,CAAEC,GAAIC,KAIjB,MAAO,CACLD,GAAI,eACJwB,SAAU,eACVC,KAAMC,OAAU4C,mBAChB9B,OAAQ,CACN0F,kBAAkB,GAEpBzC,gBAAkBrF,IAChB,MAAM+H,EAAoC,CACxC,SAAY,WACZ,SAAY,gBAEd,GAAe,IAAX/H,EAAE/B,MACJ,MAAO,CACLyC,MAAOV,EAAEU,MACTzC,MAAO8J,EAAU/H,EAAE/B,QAAU+B,EAAE/B,QAIrC2F,WAAYnB,MAAOzC,EAAaiC,KAC9B,MAAM+F,EAAkBJ,EAAS5H,EAAG,SAAU,aAC1C4H,EAAS5H,EAAG,gBAAiB,aAC9B4H,EAAS5H,EAAG,SAAU,aACrB4H,EAAS5H,EAAG,SAAU,YAC1B,GAAI,gBAAgBH,KAAKoC,EAAEyB,gBAAgBzF,QAAU+J,EAOnD,aANMnH,eACJ,8BACA,GACA,6BACA,CAAC,CAAEC,KAAM,KAAMC,KAAM,YAEhB,EAET,GAAIiH,EAEF,aADMpH,KACC,EAET,MAAMqH,EAAaL,EAAS5H,EAAG,SAAU,aACvC4H,EAAS5H,EAAG,SAAU,aACtB4H,EAAS5H,EAAG,SAAU,YAWxB,OATIiI,GAAcxK,EAAUkD,KAAO,SAC3BE,eACJ,wCACA,GACA,oCACA,CAAC,CAAEC,KAAM,KAAMC,KAAM,aAIO,aAA5BkB,EAAEC,iBAAiBjE,OAAwBoB,EAA4BW,WAC7DkI,eAAkB,wDAC5B,CAAEC,OAAQ,8BAQhBC,cAAeA,CAACvC,EAAa7F,EAAQiC,KAEnC,GACEjB,EAAYiB,EAAG,QACc,oBAA7BA,EAAEC,iBAAiBjE,MACnB,CACA,MAAMoK,EAAoB,IAAIxC,GACxByC,EAAoBV,EAASS,EAAS,SAAU,YAChDE,EAAoBX,EAASS,EAAS,SAAU,YAChDG,EAAUA,CAAC3I,EAAcC,KAC7BuI,EAAQI,QAASvC,IACXA,EAAEvG,MAAMC,KAAOC,IACjBqG,EAAEpG,SAAWA,EACTA,IAAUoG,EAAEjI,MAAQ,QAI9B,OAAIqK,GACFE,EAAQ,UAAU,GAOhBF,GAAqBC,GACvBC,EAAQ,UAAU,GAClBA,EAAQ,iBAAiB,GAClBH,IAGPC,IACCC,GACD1C,EAAE1E,KAAMgD,GAAqB,WAAfA,EAAExE,MAAMC,IAA8B,IAAXuE,EAAElG,SAE3CuK,EAAQ,iBAAiB,GACzBA,EAAQ,UAAU,IAEbH,KAlBLG,EAAQ,UAAU,GAClBA,EAAQ,UAAU,GAClBA,EAAQ,iBAAiB,GAClBH,GAiBX,OAAOxC,GAET9B,WAAa/D,IAENA,GAAKA,EAAEmB,KAAMgD,IAAK,IAAAuE,EACnB,MAAO,6BAA6B7I,KAAK,IAAI,OAADsE,QAAC,IAADA,GAAQ,QAAPuE,EAADvE,EAAGxE,aAAK,IAAA+I,OAAA,EAARA,EAAU9I,MAAqB,KAAZuE,EAAElG,QAAiBkG,EAAErE,WAE/E,CAAC,4BAEH,KAET2B,mBAAqBzB,IACZ,CACL2B,YAAa3B,EACV+C,OAAQoB,GAAMA,EAAElG,OAChB0K,OAAO,CAACC,EAAQC,KACR,IAAID,EAAG,CAACC,EAAElJ,MAAM+B,SAAUmH,EAAE5K,QAClC,IACL2D,IAAK5B,EACF+C,OAAQoB,GAAMA,EAAElG,OAAgC,oBAAhBkG,EAAExE,MAAMiC,KACxCqB,IAAKkB,GAAMA,EAAExE,MAAMiC,IAAIuC,MAG9B3B,KAAMC,gBACEiF,KACC,GAET1F,UAAYC,GAAWA,EAAEf,cAAcZ,OACvCwB,QAAUG,IACR,MAAM6G,EAASA,CAACC,EAAS,MAChB,CACLrI,MAAOqI,EAAOjI,KACd7C,MAAO,GACP6B,SAAsC,mBAAf,OAANiJ,QAAM,IAANA,OAAM,EAANA,EAAQjJ,WAAyBiJ,EAAOjJ,SACzDH,MAAO,CACLC,IAAU,OAANmJ,QAAM,IAANA,OAAM,EAANA,EAAQnJ,KAAM,GAClB8B,SAAe,OAANqH,QAAM,IAANA,OAAM,EAANA,EAAQrH,UAAW,GAC5B6F,WAAiB,OAANwB,QAAM,IAANA,OAAM,EAANA,EAAQxB,YAAa,GAChCyB,UAAgB,OAAND,QAAM,IAANA,OAAM,EAANA,EAAQC,WAAY,GAC9B9D,YAAkB,OAAN6D,QAAM,IAANA,OAAM,EAANA,EAAQ7D,aAAc,GAClCC,OAAa,OAAN4D,QAAM,IAANA,OAAM,EAANA,EAAQ5D,QAAS,GACxBvD,IAA4B,oBAAV,OAANmH,QAAM,IAANA,OAAM,EAANA,EAAQnH,KAAqBmH,EAAOnH,SAAMqH,EACtDC,aAAmB,OAANH,QAAM,IAANA,OAAM,EAANA,EAAQG,cAAe,IACpCC,OAAQ,CACN,CAAEzI,MAAO,WAAYzC,MAAO,YAC5B,CAAEyC,MAAO,eAAgBzC,MAAO,gBAKlCmL,EAAwB,CAC5BN,EAAO,CACLlJ,GAAI,SACJkB,KAAM,yBACNkI,SAAU,MACVzB,UAAW,YACXpC,MAAOqC,EAAS6B,OAAQC,WACxBpE,WAAYuC,EAAc4B,OAAQC,WAClC5H,QAAS,SACTE,IAAM5B,GACJxC,EAAQqE,gBAAgB7B,EAAEL,MAAM+B,QAAS1B,EAAE/B,SAE/C6K,EAAO,CACLlJ,GAAI,SACJkB,KAAM,uBACNkI,SAAU,MACVlJ,UAAU,EACVoJ,YAAa,kBACb3B,UAAW,UACX7F,QAAS,SACTyD,MAAOqC,EAAS6B,OAAQE,SACxBrE,WAAYuC,EAAc4B,OAAQE,SAClC3H,IAAM5B,GACJxC,EAAQqE,gBAAgB7B,EAAEL,MAAM+B,QAAS1B,EAAE/B,SAE/C6K,EAAO,CACLlJ,GAAI,gBACJkB,KAAM,gCACNkI,SAAU,MACVlJ,UAAU,EACVyH,UAAW,qBACX2B,YAAa,kBACbxH,QAAS,iCACTyD,MAAOqC,EAAS6B,OAAQC,WACxBpE,WAAYuC,EAAc4B,OAAQC,WAClC1H,IAAM5B,GACJxC,EAAQqE,gBAAgB7B,EAAEL,MAAM+B,QAAS1B,EAAE/B,SAE/C6K,EAAO,CACLlJ,GAAI,SACJkB,KAAM,uBACNkI,SAAU,MACVlJ,UAAU,EACVyH,UAAW,UACX2B,YAAa,kBACbxH,QAAS,SACTyD,MAAOqC,EAAS6B,OAAQG,SACxBtE,WAAYuC,EAAc4B,OAAQG,SAClC5H,IAAM5B,GACJxC,EAAQqE,gBAAgB7B,EAAEL,MAAM+B,QAAS1B,EAAE/B,SAE/C6K,EAAO,CACLlJ,GAAI,WACJkB,KAAM,uBACNkI,SAAU,WACVzB,UAAW,WACX7F,QAAS,uBACTyD,MAAOqC,EAAS6B,OAAQI,UACxBvE,WAAYuC,EAAc4B,OAAQI,UAClC7H,IAAM5B,GACJxC,EAAQqE,gBAAgB7B,EAAEL,MAAM+B,QAAS1B,EAAE/B,SAE/C6K,EAAO,CACLlJ,GAAI,YACJkB,KAAM,0BACNkI,SAAU,cACVzB,UAAW,cACX7F,QAAS,0BACTyD,MAAOqC,EAAS6B,OAAQK,WACxBxE,WAAYuC,EAAc4B,OAAQK,WAClC9H,IAAM5B,GACJxC,EAAQqE,gBAAgB7B,EAAEL,MAAM+B,QAAS1B,EAAE/B,UAG3CiL,EAAcjH,EAAEC,iBAAiBjE,MACjC0L,EAAcrD,MAAMC,QAAQtE,EAAE+C,cAChC/C,EAAE+C,aACF,GAEEqD,EAAoBe,EAAYT,OACpC,CAAC3C,EAAU4D,KACT,MAAMC,EAAiBpF,kBAAKkF,EAAa,CACvCjJ,MAAOkJ,EAAclJ,QAavB,OAXImJ,GAEoC,KAApCA,EAAelK,MAAMuJ,aACrBW,EAAelK,MAAMuJ,aAAeA,IAEpCW,EAAe5L,MAAQ,IAEzB+H,EAAI8D,KAAKD,IAET7D,EAAI8D,KAAKF,GAEJ5D,GAET,IAGF,OAAO/D,EAAEf,cAAcyH,OAAO,CAAC3C,EAAe6C,KAC5C,MAAM/G,EAAoBuG,EAAQtF,OAC/BmD,GACCA,EAAEvG,MAAMqJ,WAAaH,EAAE5K,QACtBiI,EAAEvG,MAAMuJ,cAAgBA,GACC,MAAxBhD,EAAEvG,MAAMuJ,cAEd,OAAOpH,EAAQxB,OAAS0F,EAAI+D,OAAOjI,GAAWkE,GAC7C,MAKT,SAAShH,IACP,IAAIgL,EAAS,GACb,MAAO,CACLpK,GAAI,aACJwB,SAAU,aACVC,KAAMC,OAAUoD,UAChBuF,gBAAiBA,KAAM,EACvBjI,UAAYC,GAAWjB,EAAYiB,EAAG,OACtCiI,OAASjI,IACP,IAAIkI,EAA6C,MAAvBlI,EAAEmI,kBACxBC,EAAwC,MAArBpI,EAAEyB,gBACrB4G,EAAgB,GAChBC,EAAgB,GAChBC,EAAkB,GAClBC,EAAgB,GACpB,MAAMpE,EAAepE,EAAE+C,cAAc,GAC/B0F,EAA2C,cAA7BzI,EAAEC,iBAAiBjE,MACjC0M,EAAgBA,KAAA,IAAAC,EAAA,OAAuB,QAAvBA,EAAM3I,EAAEyB,uBAAe,IAAAkH,OAAA,EAAjBA,EAAmB3M,OACzC4M,EAAmBA,KAAA,IAAAC,EAAA,OAAyB,QAAzBA,EAAM7I,EAAEmI,yBAAiB,IAAAU,OAAA,EAAnBA,EAAqB7M,OACpDoI,EAAYoC,QAASvC,IACnB,OAAQA,EAAEvG,MAAMC,IACd,IAAK,SACH0K,EAAgBpE,EAAEjI,MAClB,MACF,IAAK,SACHsM,EAAgBrE,EAAEjI,MAClB,MACF,IAAK,SACHuM,EAAkBtE,EAAEjI,MACpB,MACF,IAAK,gBACHwM,EAAgBvE,EAAEjI,MAClB,SAGN,MAAM8M,EAAsDA,IAC1DV,GACAF,GACoB,aAApBQ,KACuB,iBAAvBE,MACmB,aAAlBP,GACmB,aAAlBC,GACoB,aAApBC,GACEnC,EAAe,CAEnB2C,WAAYA,IAAM,CACY,aAA5B/I,EAAEC,iBAAiBjE,MACnBoB,EAA4BgH,IAE9B4E,SAAUA,IAAM,EACbF,IACiB,aAAlBT,GACoB,aAAlBC,GACoB,aAApBC,GACkB,aAAlBC,GAEJS,SAAUA,IAAM,EAAER,EAAiC,aAApBF,GAC/BW,aAAcA,IAAM,EACjBT,EACDK,KACqB,aAAlBR,GACmB,aAAlBE,GACiB,aAAlBF,GACqB,aAApBC,GAEN,gCAAiCY,IAAM,CACrCV,EACkB,aAAlBJ,IAGJN,EAASqB,OAAOC,KAAKjD,GAASM,OAAO,CAAC4C,EAAkBC,IAClDnD,EAAQmD,KAAOrF,MAAMsF,SAAiBD,EACnCD,EACN,kBAEL5G,aAAcA,KACZ,GAAIqF,EAAQ,OAAOtM,EAASsM,IAE9BvI,mBAAoBA,KAClB,GAAIuI,EAAQ,CACV,MAAMtI,EAAU,aAChB,MAAO,CACLC,YAAa,CAAE,CAACD,GAAUsI,GAC1BpI,IAAKpE,EAAQqE,gBAAgBH,EAASsI,OAOhD,SAAS/K,IACP,IAAIyM,EAAoB,MACxB,MAAO,CACL9L,GAAI,mBACJwB,SAAU,yBACVC,KAAMC,OAAUoD,UAChBwF,OAASjI,IACP,IAAKA,EAAE0J,WAAY,OACnB,MAAMC,EAAe3J,EAAE0J,WAAW1N,MAC5B4N,EAAYpO,EAAUkD,IACtBmL,EAAgB7J,EAAEyB,gBAAgBzF,MAClC8N,EACmB,MAAvB9J,EAAEmI,kBAA4BnI,EAAEmI,kBAAkBnM,MAAQ,GACtD+N,EACsB,MAA1B/J,EAAEgK,qBACEhK,EAAEgK,qBAAqBtM,MAAMkE,cAC5B,EAEDqI,EAA4C,CAChD,eAAgB,CACG,aAAjBN,EACA,8CAA8C/L,KAAKiM,IAC9B,aAAlBA,GACC,6BAA6BjM,KAAKkM,IAClCC,GAA6B,IAEnC,qBAAsB,CACpBH,GAAa,EACI,aAAjBD,GAEF,mBAAoB,CACD,aAAjBA,EACkB,aAAlBE,EAC4B,iBAA5BC,GAEF,uBAAwB,CACJ,aAAlBD,EACiB,iBAAjBF,EAC4B,iBAA5BG,GAEF,eAAgB,CACG,aAAjBH,GAEF,mBAAoB,CACD,iBAAjBA,EACC,QAAQ/L,KAAKkM,IAA4B,WAAWlM,KAAKiM,IAC1D,wCAAwCjM,KAAKiM,IACxB,aAAlBA,GACC,6BAA6BjM,KAAKkM,KAG1CL,EAAoBL,OAAOC,KAAKY,GAAgBvD,OAC9C,CAACd,EAAgB2D,IACfU,EAAeV,GAAKrF,MAAMsF,SAAWD,EAAM3D,EAC7C,QAGJlD,aAAcA,KACZ,GAAyB,OAArB+G,EACF,OAAOhO,EAASgO,IAEpBjK,mBAAoBA,KAClB,GAAyB,OAArBiK,EAA4B,CAC9B,MAAMhK,EAAU,YAChB,MAAO,CACLC,YAAa,CAAE,CAACD,GAAUgK,GAC1B9J,IAAKpE,EAAQqE,gBAAgBH,EAASgK,MAI5C1J,UAAYC,GAAWA,EAAE0J,WAAW1N,OAIxC,MAAO,CACL9B,SACAE,WACAE,0B,qBCxlCN,MAAM4P,EAA2B,IAAgB,EAAQ,CAAC,CAAC,SAAShR,KAErD,gB,kDCLT,SAAUA,EAAOC,EAAUC,EAAYC,EAAYC,EAAYC,EAAWC,GAC9E,OAAQI,yBAAcC,yBAAasQ,qCAAyBhR,EAAKiR,UAAW,CAC1ElQ,OAAQf,EAAKe,OACbmQ,YAAalR,EAAKkR,YAClBC,YAAanR,EAAKmR,YAClBjQ,sBAAuBlB,EAAKkB,sBAC5BkQ,WAAYpR,EAAKiB,SACjBA,SAAUjB,EAAKgB,eACfqQ,UAAWrR,EAAKsR,SACf,KAAM,GAAI,CAAC,SAAU,cAAe,cAAe,wBAAyB,aAAc,WAAY,c,gBCN5FxP,+BAAgB,CAC3B4D,KAAM,kBACN3D,WAAY,CAAEwP,wBACdC,MAAO,CACH,WACA,WAEJtH,KAAMA,KAAA,CACF+G,SAAU,sBAEdQ,MAAO,CACHzQ,eAAgB,CACZiF,KAAMyL,UAEVR,YAAa,CACTjL,KAAMoK,QACN1P,SAAS,GAEbwQ,YAAa,CACTlL,KAAM0L,QAEV5Q,OAAQ,CACJkF,KAAMgK,OACN2B,UAAU,GAEd1Q,sBAAuB,CACnB+E,KAAM0L,OACNC,UAAU,IAGlBC,QAAS,CACL5Q,SAAS4E,EAAe/B,GACpBlC,KAAKkQ,MAAM,WAAYjM,EAAU/B,IAErCwN,QAAQS,GACJnQ,KAAKkQ,MAAM,UAAWC,O,qBCnClC,MAAMhB,EAA2B,IAAgB,EAAQ,CAAC,CAAC,SAAShR,KAErD,U,kCCPf,wEAKYkO,EALZ,gDAeM,SAAU1B,IACZ,MAAM1B,EAAO1I,iBAAS,KAChB,YAAEmF,EAAW,YAAE0K,GAAgBzK,iBAE/B0K,EAAmB5K,UACrB,IACI,MAAM6K,QAAY5K,EAAY,gBAC9B,OAAO,IAAG4K,GAAK,KAAKxK,MAAM,KAAKG,IAAKD,GAAiBA,EAAKG,QAC5D,MAAOC,GACLC,QAAQC,MAAM,GAAGF,GAErB,MAAO,IAGLsE,EAAWjF,UACb,MAAM8K,EAAc,CAChB,CACI9G,QAAS4C,EAAQE,QACjBpE,MAAO,GACPD,WAAY,GACZsI,UAAW,qBACXC,SAAS,EACTC,SAAU,YAEd,CACIjH,QAAS4C,EAAQC,UACjBnE,MAAO,GACPD,WAAY,GACZsI,UAAW,qBACXC,SAAS,EACTC,SAAU,YAEd,CACIjH,QAAS4C,EAAQG,QACjBrE,MAAO,GACPD,WAAY,GACZsI,UAAW,qBACXC,SAAS,EACTC,SAAU,YAEd,CACIjH,QAAS4C,EAAQsE,aACjBxI,MAAO,GACPD,WAAY,GACZuI,SAAS,GAEb,CACIhH,QAAS4C,EAAQI,SACjBtE,MAAO,GACPD,WAAY,GACZuI,SAAS,EACTC,SAAU,iBAEd,CACIjH,QAAS4C,EAAQK,UACjBvE,MAAO,GACPD,WAAY,GACZuI,SAAS,EACTC,SAAU,qBAGlB,IACI,MAAME,QAAqBP,IACrBC,QAAiB5K,EAAY2G,EAAQwE,wBACrCC,EAAWC,KAAKC,MAAMV,GAAK,IAEjCC,EAAY9E,QAASwF,IACbA,EAAIP,WAAaQ,qBAAQN,KACzBK,EAAIR,QAAUG,EAAanK,SAASwK,EAAIP,WAE5C,MAAMS,EAAS1J,kBAAKqJ,EAAU,CAAErH,QAASwH,EAAIxH,UACzC0H,IACAF,EAAI9I,MAAQgJ,EAAOhJ,MACnB8I,EAAI/I,WAAaiJ,EAAOjJ,cAGhCe,EAAKhI,MAAQsP,EAAYxK,OAAQqL,GAAWA,EAAEX,SAChD,MAAOrK,GACL6C,EAAKhI,MAAQsP,EACblK,QAAQC,MAAM,GAAGF,KAKnBoE,EAAYf,IACd,MAAMnB,EAAOb,kBAAKwB,EAAKhI,MAAO,CAAEwI,YAChC,OAAInB,EACG,IAAI/E,KAAK+E,EAAKJ,aAAe,IAAI3E,KAAK8N,OAAQC,kBACtC,GAEJhJ,EAAKH,MAET,IAGLsC,EAAiBhB,IACnB,MAAMjG,EAAOiE,kBAAKwB,EAAKhI,MAAO,CAAEwI,YAChC,OAAIjG,EACI,IAAID,KAAKC,EAAK0E,aAAe,IAAI3E,KAAK8N,OAAQC,kBACvC,GAEJ9N,EAAK0E,WAET,IAGLqJ,EAAWA,IAAMnB,EAAY/D,EAAQwE,uBAAwBE,KAAKS,UAAUvI,EAAKhI,QAEvF,MAAO,CACHgI,OACAyB,WACA6G,WACA/G,WACAC,kBA3HR,SAAY4B,GACRA,EAAA,mDACAA,EAAA,+BACAA,EAAA,uBACAA,EAAA,2BACAA,EAAA,qBACAA,EAAA,yBACAA,EAAA,sBAPJ,CAAYA,MAAO","file":"js/chunk-5bb71f0e.9a2eeeae.js","sourcesContent":["import { resolveComponent as _resolveComponent, createVNode as _createVNode, withCtx as _withCtx, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  const _component_his_standard_form = _resolveComponent(\"his-standard-form\")!\n  const _component_ion_page = _resolveComponent(\"ion-page\")!\n\n  return (_openBlock(), _createBlock(_component_ion_page, null, {\n    default: _withCtx(() => [\n      _createVNode(_component_his_standard_form, {\n        formLabel: \"Testing\",\n        fields: _ctx.fields,\n        onFinishAction: _ctx.onFinish,\n        cancelDestinationPath: _ctx.patientDashboardUrl()\n      }, null, 8, [\"fields\", \"onFinishAction\", \"cancelDestinationPath\"])\n    ]),\n    _: 1\n  }))\n}","import { AppEncounterService } from \"@/services/app_encounter_service\";\n\nexport class HtsTestingService extends AppEncounterService {\n    constructor(patientID: number, providerID = -1) {\n        super(patientID, 197, providerID)\n    }\n\n    getRecentAccesspoint() {\n        return this.getFirstValueCoded('HTS Access Type')\n    }\n}","\nimport { FieldType } from \"@/components/Forms/BaseFormElements\";\nimport { defineComponent, ref } from \"vue\";\nimport { Field, Option } from \"@/components/Forms/FieldInterface\";\nimport { IonPage } from \"@ionic/vue\";\nimport { HtsTestingService } from \"@/apps/HTS/services/hts_testing_service\";\nimport { infoActionSheet } from \"@/utils/ActionSheets\";\nimport keyboard from \"@/utils/PopupKeyboard\";\nimport { find } from \"lodash\";\nimport { toDate } from \"@/utils/Strs\";\nimport { KitProp, TestKit } from \"../../composables/testKits\";\nimport UserProp from \"@/composables/userproperty\"\nimport { alertConfirmation } from \"@/utils/Alerts\";\nimport HisStandardForm from \"@/components/Forms/HisStandardForm.vue\";\nimport { StartHtsEncounter } from \"@/apps/HTS/composables/HtsFormEncounter\";\n\nexport default defineComponent({\n  components: { IonPage, HisStandardForm },\n  setup() {\n    const fields = ref<Field[]>([])\n    const service = new HtsTestingService(-1)\n    const {\n      htsClient,\n      toOption,\n      saveEncounter,\n      toYesNoOption,\n      mapStrToOptions,\n      patientDashboardUrl,\n      toConditionalOptions\n    }  = StartHtsEncounter({\n      onInitVisit: () => {\n        fields.value = [\n          accessPointTypeField(),\n          facilityAccessPointField(),\n          communityAccessPoints(),\n          testsOfferedField(),\n          lastHivTestResultField(),\n          lastHivTestTypeField(),\n          lastTimeHIVTestedField(),\n          arvHistoryField(),\n          drugTakenField(),\n          mostRecentDrugHiddenField(),\n          timeSinceDrugTaken(),\n          clientRiskCategoryField(),\n          testResultsField(),\n          hivTestKitDetailsField(),\n          hivResultHiddenField(),\n          hivPatientCategoryField()\n        ]\n      }\n    })\n\n    function onFinish(_: any, computedData: any) {\n      saveEncounter({\n        encounterName: 'Testing',\n        encounterTypeID: service.encounterTypeID, \n        computedData\n      })\n    }\n\n    /**\n     * HIV tests can be marked as incomplete if the client tests Positive\n     * on the first test and does not complete the other three or two tests to confirm the positive results.\n     * This may happen if the facility runsout of test kits or the client walksout without completing \n     * tests.\n     * @param testingFieldData \n     */\n    function threeTierHIVtestNotComplete(testingFieldData: Option[]) {\n      let testOnePositive = false\n      let isIncompleteThreeTier = false\n      for (const opt of testingFieldData) {\n        if (opt.other.id === 'test_1' && opt.value === 'Positive') {\n          testOnePositive = true\n        } else if (\n          /test_2|test_1_repeat|test_3/i.test(`${opt?.other?.id}`) && \n          opt.value === '' && !opt.disabled\n        ) {\n          isIncompleteThreeTier = true\n        }\n      } \n      return testOnePositive && isIncompleteThreeTier\n    }\n\n    function validateTimeUnit(v: Option) {\n      const maxDaysAllowed = 90;\n      const maxWeeksAllowed = 12;\n      const maxMonthsAllowed = 24;\n\n      if (parseInt(`${v.other.value}`) <= 0 && !/day/i.test(v.other.timeUnit)) {\n        return [`Enter ${v.other.timeUnit} greater than zero`];\n      }\n      if(v.other.timeUnit === 'Days' && parseInt(`${v.other.value}`) > maxDaysAllowed) {\n        return [`Enter ${v.other.timeUnit} less than ${maxDaysAllowed}, use Weeks Instead`];\n      }\n      if(v.other.timeUnit === 'Weeks' && parseInt(`${v.other.value}`) > maxWeeksAllowed) {\n        return [`Enter ${v.other.timeUnit} less than ${maxWeeksAllowed}, use Months Instead`];\n      }\n      if(v.other.timeUnit === 'Months' && parseInt(`${v.other.value}`) > maxMonthsAllowed) {\n        return [`Enter ${v.other.timeUnit} less than ${maxMonthsAllowed}, use Years Instead`];\n      }\n      if (v.other.value.length > 1 && v.other.value[0] === \"0\") {\n        return [`Value ${v.other.value} is invalid!`];\n      }\n      if (new Date(v.other.date) < new Date(htsClient.birthDate)) {\n        return [\n          `${\n            v.label\n          } is greater than client's age of ${htsClient.age} Years`,\n        ];\n      }\n      return null;\n    }\n\n    function inclonclusiveResultDialog() {\n      return infoActionSheet(\n        \"Reschedule test\",\n        \"\",\n        \"HIV result is inconclusive, schedule another test in 2 weeks\",\n        [{ name: \"Ok\", slot: \"start\" }]\n      );\n    }\n    \n    function testOffered(formData: any, test: string) {\n      return formData.tests_offered.some((v: Option) => v.value === test);\n    }\n\n    function accessPointTypeField(): Field {\n      return {\n        id: \"accesspoint_type\",\n        helpText: \"Access point type\",\n        type: FieldType.TT_SELECT,\n        isRequired: () => true,\n        finalComputedValue: (v: Option) => {\n          const concept = \"HTS Access Type\"\n          return {\n            offlineMeta: {\n              [concept] : v.value\n            },\n            obs: service.buildValueCoded(concept, v.value),\n          };\n        },\n        options: () => {\n          return [\n            { label:\"Health Facility\", value:\"Health Facility\"},\n            { label: \"Community\", value: \"Community\" },\n            { label: \"Facility Referred from Community\", value: \"Health Facility\" }\n          ];\n        },\n      };\n    }\n\n    function facilityAccessPointField(): Field {\n      return {\n        id: \"facility_access_points\",\n        helpText: \"Health facility access points\",\n        type: FieldType.TT_SELECT_GRID,\n        isRequired: () => true,\n        condition: (f: any) => f.accesspoint_type.value === \"Health Facility\",\n        finalComputedValue: (v: Option) => {\n          return {\n            obs: service.buildValueText(\n              \"Location where test took place\",\n              `${v.value}`\n            ),\n          };\n        },\n        config: {\n          columnsPerRow: 2\n        },\n        options: () => {\n          return [\n            {label: \"1 | VCT\", value: \"VCT\"},\n            {label: \"2 | ANC\", value: \"ANC First Visit\"},\n            {label: \"3 | Inpatient\", value: \"Inpatient\"},\n            {label: \"4 | STI\", value: \"STI\"},\n            {label: \"5 | PMTCT-Follow-up (ANC FUP, Mat, Post-nat, BF)\", value: \"PMTCT FUP\"},\n            {label: \"6 | Index\", value: \"Index\"},\n            {label: \"7 | Paediatric\", value: \"Paediatric\"},\n            {label: \"8 | VMMC\", value: \"VMMC\"},\n            {label: \"9 | Malnutrition\", value: \"Malnutrition\"},\n            {label: \"10 | TB\", value: \"TB\"},\n            {label: \"11 | OPD\", value: \"OPD\"},\n            {label: \"12 | Other PITC (PrEP, dental e.t.c)\", value: \"Other\"},\n            {label: \"18 | SNS (Social Network Strategies)\", value: \"SNS\"},\n          ];\n        },\n      };\n    }\n\n    function communityAccessPoints(): Field {\n      return {\n        id: \"community_access_points\",\n        helpText: \"Community access points\",\n        type: FieldType.TT_SELECT,\n        condition: (f: any) => f.accesspoint_type.value === \"Community\",\n        isRequired: () => true,\n        finalComputedValue: (v: Option) => {\n          return {\n            obs: service.buildValueText(\n              \"Location where test took place\",\n              `${v.value}`\n            ),\n          };\n        },\n        options: () => {\n          return [\n            {label: \"13 | VCT\", value: \"VCT\"},\n            {label: \"14 | Index\", value: \"Index\"},\n            {label: \"15 | VMMC\", value: \"VMMC\"},\n            {label: \"16 | Other\", value: \"Other\"},\n            {label: \"17 | SNS\", value: \"SNS\"},\n            {label: \"19 | Mobile\", value: \"Mobile\"},\n          ];\n        },\n      };\n    }\n\n    function testsOfferedField(): Field {\n      let availableTests: string[] = [\n        'HIV',\n        'Syphilis',\n        'Hepatitis B'\n      ]\n      return {\n        id: \"tests_offered\",\n        helpText: \"Tests to be offered today?\",\n        type: FieldType.TT_MULTIPLE_SELECT,\n        init: async () => {\n          try {\n            const { getUserProp } = UserProp()\n            const res = await getUserProp('HTS_PROGRAMS')\n            const tests = res.split(',').filter(\n              (prop: string) => /HIV|syphilis|hepatitis/i.test(prop)\n            ).map((test: string) => test.replace(/test/i, '').trim())\n            if (tests.length >= 1) availableTests = tests\n          } catch (e) {\n            console.error(e)\n            return false\n          }\n          return true\n        },\n        isRequired: () => true,\n        condition: () => availableTests.length > 1,\n        defaultOutput: () => mapStrToOptions(availableTests),\n        options: () => mapStrToOptions(availableTests),\n        config: {\n          buildOptionsOnce: true\n        },\n      };\n    }\n\n    function lastHivTestResultField(): Field {\n      return {\n        id: \"last_hiv_result\",\n        helpText: \"Last HIV Test\",\n        type: FieldType.TT_SELECT,\n        isRequired: () => true,\n        finalComputedValue: (v: Option) => {\n          const concept =  \"Previous HIV Test Results\"\n          return {\n            offlineMeta: {\n              [concept]: v.value\n            },\n            obs: service.buildValueCoded(concept, v.value)\n          };\n        },\n        options: () => {\n          return toConditionalOptions([\n            [\"Never Tested\"],\n            [\"Negative\"],\n            [\"Positive\"],\n            [\"Exposed infant\"],\n            [\"Invalid or inconclusive\"],\n          ]);\n        },\n      };\n    }\n\n    function lastHivTestTypeField(): Field {\n      return {\n        id: \"last_hiv_perfomed\",\n        helpText: \"Last HIV test performed\",\n        type: FieldType.TT_SELECT,\n        isRequired: () => true,\n        condition: (f: any) =>\n          ![\"Never Tested\", \"Exposed infant\"].includes(f.last_hiv_result.value),\n        finalComputedValue: (v: Option) => {\n          const concept = \"Previous HIV test done\"\n          return {\n            offlineMeta: {\n              [concept]: v.value\n            },\n            obs: service.buildValueCoded(concept, v.value)\n          };\n        },\n        defaultOutput: (f: any) => {\n          if (/exposed infant/i.test(f.last_hiv_result.value)) {\n            return toOption('Professional')\n          }\n        },\n        options: (f: any) => {\n          return toConditionalOptions([\n            [\"Self\"],\n            [\n              \"Initial professional\",\n              !/Negative|Inconclusive/i.test(f.last_hiv_result.value),\n            ],\n            [\"Professional\"],\n          ]);\n        },\n      }\n    }\n\n    function lastTimeHIVTestedField(): Field {\n      return {\n        id: \"last_time_hiv_tested\",\n        helpText: \"Time since last HIV test\",\n        type: FieldType.TT_AGE_INPUT,\n        condition: (f: any) =>\n          f.last_hiv_result.value && f.last_hiv_result.value != \"Never Tested\",\n        isRequired: () => true,\n        beforeNext: async (v: Option, f: any) => {\n          if (v.other.monthsAgoInt >= 12 && !testOffered(f, \"HIV\")) {\n            await infoActionSheet(\n              \"Recommendation Alert\",\n              \"\",\n              \"Please consider testing client for HIV\",\n              [\n                {\n                  name: \"Ok\",\n                  slot: \"start\",\n                  color: \"primary\",\n                },\n              ]\n            );\n          }\n          return true;\n        },\n        validation: (v: Option) => validateTimeUnit(v),\n        finalComputedValue: (v: Option) => {\n          const concept = \"Time of HIV test\"\n          return {\n            offlineMeta: {\n              [concept]: v.value\n            },\n            obs: service.buildObs(concept, {\n              'value_datetime': v.other.date,\n              'value_text': v.value\n            })\n          }\n        },\n        config: {\n          excludeUnits: [\"Hours\"],\n        },\n      };\n    }\n\n    function arvHistoryField(): Field {\n      return {\n        id: \"last_taken_drugs\",\n        helpText: \"Ever taken the following drugs?\",\n        type: FieldType.TT_MULTIPLE_YES_NO,\n        isRequired: () => true,\n        finalComputedValue: (v: Option[]) => {\n          return {\n            obs: v.map((d) =>\n              service.buildValueCoded(d.other.concept, d.value)\n            ),\n          };\n        },\n        options: (f: any) => {\n          if (f.last_taken_drugs) return f.last_taken_drugs;\n          return [\n            toYesNoOption(\"PrEP or infant NVP\", {\n              concept: \"Taken Prep before\",\n            }),\n            ...(()=> {\n              if (`${f.last_hiv_result?.value}` != 'Negative') {\n                return [toYesNoOption(\"ART\", { concept: \"Taken ARV Before\" })]\n              }\n              return []\n            })(),\n            toYesNoOption(\"PEP\", { concept: \"Taken PEP before\" }),\n          ];\n        },\n      };\n    }\n\n    function drugTakenField(): Field {\n      /**\n       * Select Most recent drug from list of drugs\n       */\n      return {\n        id: \"drug_taken\",\n        helpText: \"Most recent drug taken\",\n        type: FieldType.TT_SELECT,\n        isRequired: () => true,\n        condition: (f: any) => {\n          let drugCount = 0 \n          for(const drug of f.last_taken_drugs) {\n            if (drug.label === 'ART' && drug.value === 'Yes') {\n              return false\n            }\n            if (drug.value === 'Yes') ++drugCount\n          }\n          return drugCount > 1\n        },\n        defaultOutput: (f: any) => {\n          const artSelected = f.last_taken_drugs.find((d: Option) => d.label === 'ART')\n          if (artSelected?.value === 'Yes') {\n            return toOption('ART')\n          }\n        },\n        finalComputedValue: (v: Option) => {\n          const concept = \"Most recent drug taken\"\n          return {\n            offlineMeta: {\n              [concept]: v.value\n            },\n            obs: service.buildValueCoded(concept, v.value)\n          }\n        },\n        options: (f: any) => {\n          return f.last_taken_drugs\n            .filter((d: Option) => d.value === \"Yes\")\n            .map((d: Option) => toOption(d.label));\n        },\n      };\n    }\n\n    function mostRecentDrugHiddenField(): Field {\n      /**\n       * Automatically determines recent drug if only one drug is Yes\n       */\n      return {\n        id: \"most_recent_drug\",\n        helpText: \"Most recent drug\",\n        type: FieldType.TT_HIDDEN,\n        condition: (f: any) =>\n          f.last_taken_drugs.filter((d: Option) => d.value === \"Yes\").length ===\n          1,\n        defaultValue: (fdata?) => {\n          return find(fdata.last_taken_drugs, { value: \"Yes\" });\n        },\n        finalComputedValue: (v: Option) => {\n          return {\n            obs: service.buildValueCoded(\n              \"Most recent drug taken\",\n              v.value\n            ),\n          };\n        },\n      };\n    }\n\n    function timeSinceDrugTaken(): Field {\n      return {\n        id: \"time_since_last_drug_taken\",\n        helpText: \"Time since last taken medication\",\n        type: FieldType.TT_AGE_INPUT,\n        condition: (f: any) =>\n          f.last_taken_drugs.some((d: Option) => d.value === \"Yes\"),\n        finalComputedValue: (v: Option) => {\n          const concept = \"Time since last taken medication\"\n          return {\n            offlineMeta: {\n              [concept]: v.value\n            },\n            obs: service.buildObs(concept, {\n              value_text: `${v.value} ago`,\n              value_datetime: v.other.date,\n            }),\n          };\n        },\n        validation: (v: Option) => validateTimeUnit(v),\n        isRequired: () => true,\n        config: {\n          excludeUnits: [\"Hours\"],\n        },\n      }\n    }\n\n    function clientRiskCategoryField(): Field {\n      return {\n        id: \"client_risk_category\",\n        helpText: \"Client Risk Category\",\n        type: FieldType.TT_SELECT,\n        isRequired: () => true,\n        finalComputedValue: (v: Option) => {\n          const concept = \"client risk category\"\n          return {\n            offlineMeta: { [concept]: v.value },\n            obs: service.buildValueCoded(concept, v.value),\n          };\n        },\n        options: () => {\n          return mapStrToOptions([\n            \"Low risk\",\n            \"On-going risk\",\n            \"High risk event in last 3 months\",\n            \"Risk assessment not done\",\n          ]);\n        },\n      };\n    }\n\n    function hivTestKitDetailsField(): Field {\n      return {\n        id: \"test_kit\",\n        helpText: \"Kit information\",\n        type: FieldType.TT_INPUT_ARRAY,\n        condition: (f: any) => f.test_results.filter((t: Option) => t.value!='')\n          .some((t: Option) => !(t.other.expiryDate && t.other.lotNo)),\n        config: {\n          columns: [\n            { label: \"Kit Name\" },\n            { label: \"Kit Lot No.\" },\n            { label: \"Kit Expiry Date\" },\n          ],\n        },\n        summaryMapValue: (v: Option) => {\n          return {\n            label: `Kit: ${v.label}`,\n            value: `Lot No: ${v.value || v.other.fields[1].value}`\n          }\n        },\n        validation: (v: Option[]) => {\n          const data = v.map((d: Option) => d.other.fields);\n          const someIncomplete = data.some((d: Option[]) => {\n            const count = d.filter((x: Option) => x.value != \"\").length;\n            return count > 0 && count < 3;\n          });\n          if (someIncomplete) {\n            return [\"Some rows have incomplete data!\"];\n          }\n          const incomplete = data.some((d: Option[]) => {\n            return d.some((x: Option) => x.value === \"\");\n          });\n          if (incomplete) {\n            return [`Some rows are missing data`];\n          }\n          return null;\n        },\n        finalComputedValue: (v: Option[]) => {\n          return {\n            obs: v\n              .map((d) => d.other.fields)\n              .map(async (options: Option[]) => {\n                const [parentObs, ...childObs] = options\n                  .filter((l: Option) => typeof l.other.obs === \"function\")\n                  .map((d: Option) => d.other.obs(d));\n                return {\n                  ...(await parentObs),\n                  child: await Promise.all(childObs),\n                };\n              }),\n          };\n        },\n        defaultOutput: (f: any) => {\n          const kits = f.test_results.filter((r: Option) => r.value!='')\n          if (kits.every((t: Option) => t.other.expiryDate && t.other.lotNo)) {\n            return kits.map((v: Option) => {\n              return {\n                label: v.label,\n                value: v.other.lotNo,\n                other: {\n                  fields: [\n                    {\n                      label: 'Kit name',\n                      value: v.label,\n                      other: {\n                        obs: () => service.buildValueText(\"Kit name\", v.label as string),\n                      }\n                    },\n                    {\n                      label: 'Kit Lot No',\n                      value: v.other.lotNo,\n                      other: {\n                        obs: () => {\n                          return service.buildValueText(\"Kit lot number\", v.other.lotNo as string)\n                        } \n                      }\n                    },\n                    {\n                      label: 'Kit expiry date',\n                      value: v.other.expiryDate,\n                      other: {\n                        obs: () => service.buildValueDate(\"kit expiry date\", v.other.expiryDate as string),\n                      }\n                    }\n                  ]\n                }\n              }\n            })\n          }\n        },\n        options: async (f: any) => {\n          const testResults: Option[] = Array.isArray(f.test_results) ? f.test_results : [];\n          const kitNameOption = (kitName: string) => ({\n            label: \"Kit Name\",\n            value: kitName,\n            clearable: false,\n            other: {\n              usefontBold: true,\n              obs: (v: Option) => service.buildValueText(\"Kit name\", v.label as string),\n            }\n          });\n          const kitLotNoOption = (lotNo: string) => ({\n            label: \"Kit Lot No.\",\n            value: lotNo,\n            other: {\n              obs: (v: Option) =>\n                service.buildValueText(\"Kit lot number\", v.value as string),\n              onclick: (val: Option) => {\n                keyboard({\n                  id: 'lot',\n                  helpText: 'Enter Lot Number',\n                  type: FieldType.TT_TEXT,\n                  isRequired: () => true\n                }, \n                (v: Option) => {\n                  val.value = v.value\n                })\n              },\n            },\n          });\n          const kitExpiryDateOption = (expiryDate: string) => ({\n            label: \"Kit Expiry Date\",\n            value: expiryDate,\n            other: {\n              obs: (v: Option) =>\n                service.buildValueDate(\"kit expiry date\", v.value as string),\n              onclick: (val: Option) => {\n                keyboard(\n                  {\n                    id: \"end_user\",\n                    helpText: \"Kit Expiry Date\",\n                    type: FieldType.TT_FULL_DATE,\n                    isRequired: () => true,\n                    validation: (v: Option) => {\n                      if (new Date(v.label) < new Date(service.date)) {\n                        return [\n                          \"Expiry date cannot be less than current date \" +\n                            toDate(service.date),\n                        ];\n                      }\n                      return null;\n                    },\n                  },\n                  (v: Option) => {\n                    val.value = v.value\n                  }\n                );\n              },\n            },\n          });\n          const enteredKits = f.test_kit === null ? [] : f.test_kit;\n          return testResults\n            .filter((t) => t.value != \"\")\n            .map((t) => {\n              const existingOption = find(enteredKits, { label: t.label });\n              if (existingOption) return existingOption;\n              return {\n                label: t.label,\n                value: \"\",\n                other: {\n                  fields: [\n                    kitNameOption(t.other.shortName),\n                    kitLotNoOption(t.other.lotNo),\n                    kitExpiryDateOption(t.other.expiryDate)\n                  ]\n                }\n              };\n            });\n        },\n      };\n    }\n\n    function testResultsField(): Field {\n      const { getLotNo, getExpiryDate, initKits } = TestKit()\n      const isStatus = (l: Option[], test: string, status: string) =>\n        find(l, {\n          value: status,\n          other: { id: test },\n        })\n          ? true\n          : false;\n      return {\n        id: \"test_results\",\n        helpText: \"Test results\",\n        type: FieldType.TT_MULTIPLE_YES_NO,\n        config: {\n          requireAllValues: false\n        },\n        summaryMapValue: (v: Option) => {\n          const resultMap: Record<string, string> = {\n            \"Positive\": \"Reactive\",\n            \"Negative\": \"Non-reactive\"\n          }\n          if (v.value != \"\") {\n            return {\n              label: v.label, \n              value: resultMap[v.value] || v.value\n            } \n          }\n        },\n        beforeNext: async (v: Option[], f: any) => {\n          const isInconclusive = (isStatus(v, \"test_2\", \"Negative\") &&\n              isStatus(v, \"test_1_repeat\", \"Positive\")) ||\n            (isStatus(v, \"test_2\", \"Positive\") &&\n              isStatus(v, \"test_3\", \"Negative\"))\n          if (/inconclusive/i.test(f.last_hiv_result.value) && isInconclusive) {\n            await infoActionSheet(\n              \"Inconclusive Re-Test Result\",\n              \"\",\n              \"Please collect DBS sample.\",\n              [{ name: \"Ok\", slot: \"start\" }]\n            );\n            return true\n          }\n          if (isInconclusive) {\n            await inclonclusiveResultDialog();\n            return true\n          }\n          const isPositive = isStatus(v, \"test_1\", \"Positive\") && \n            isStatus(v, \"test_2\", \"Positive\") &&\n            isStatus(v, \"test_3\", \"Positive\")\n          \n          if (isPositive && htsClient.age <= 0) {\n            await infoActionSheet(\n              \"<12 months old all HIV tests reactive\",\n              \"\",\n              \"Please collect DBS sample for EID\",\n              [{ name: \"Ok\", slot: \"start\" }]\n            );\n          }\n\n          if (f.accesspoint_type.value != \"Community\" && threeTierHIVtestNotComplete(v)) {\n            if (!(await alertConfirmation(\"Are you sure you want to save incomplete HIV results?\",\n              { header: \"Incomplete HIV results!\" }\n            ))) {\n              return false\n            }\n          }\n\n          return true;\n        },\n        onValueUpdate: (l: Option[], v: any, f: any) => {\n          // Manage Three test algorithm for HIV results\n          if (\n            testOffered(f, \"HIV\") &&\n            f.accesspoint_type.value === \"Health Facility\"\n          ) {\n            const results: Option[] = [...l];\n            const testOneIsPositive = isStatus(results, \"test_1\", \"Positive\");\n            const testTwoIsPositive = isStatus(results, \"test_2\", \"Positive\");\n            const disable = (test: string, disabled: boolean) => {\n              results.forEach((r) => {\n                if (r.other.id === test) {\n                  r.disabled = disabled;\n                  if (disabled) r.value = \"\";\n                }\n              });\n            };\n            if (testOneIsPositive) {\n              disable(\"test_2\", false);\n            } else {\n              disable(\"test_2\", true);\n              disable(\"test_3\", true);\n              disable(\"test_1_repeat\", true);\n              return results;\n            }\n            if (testOneIsPositive && testTwoIsPositive) {\n              disable(\"test_3\", false);\n              disable(\"test_1_repeat\", true);\n              return results;\n            }\n            if (\n              testOneIsPositive &&\n              !testTwoIsPositive &&\n              l.some((d) => d.other.id === \"test_2\" && d.value != \"\")\n            ) {\n              disable(\"test_1_repeat\", false);\n              disable(\"test_3\", true);\n            }\n            return results;\n          }\n          return l;\n        },\n        validation: (v: Option[]) => {\n          // Test 1, Test 2 and Test 1 Repeat and Test 3 are optional\n          if (!v || v.some((d) => {\n              return /syphilis|hepatitis|test_1/i.test(`${d?.other?.id}`) && d.value === \"\" && !d.disabled\n          })) {\n            return [\"Result entry incomplete!\"];\n          }\n          return null;\n        },\n        finalComputedValue: (v: Option[]) => {\n          return {\n            offlineMeta: v\n              .filter((d) => d.value)\n              .reduce((a: any, c: any) => {\n                return {...a, [c.other.concept]: c.value }\n              }, {}),\n            obs: v\n              .filter((d) => d.value && typeof d.other.obs === \"function\")\n              .map((d) => d.other.obs(d)),\n          };\n        },\n        init: async () => {\n          await initKits()\n          return true\n        },\n        condition: (f: any) => f.tests_offered.length,\n        options: (f: any) => {\n          const option = (params = {} as any) => {\n            return {\n              label: params.name,\n              value: \"\",\n              disabled: typeof params?.disabled === \"boolean\" ? params.disabled : false,\n              other: {\n                id: params?.id || \"\",\n                concept: params?.concept || \"\",\n                shortName: params?.shortName || \"\",\n                category: params?.category || \"\",\n                expiryDate: params?.expiryDate || \"\",\n                lotNo: params?.lotNo || \"\",\n                obs: typeof params?.obs === \"function\" ? params.obs : undefined,\n                accessPoint: params?.accessPoint || \"*\",\n                values: [\n                  { label: \"Reactive\", value: \"Positive\" }, \n                  { label: \"Non-reactive\", value: \"Negative\" }\n                ]\n              }\n            }\n          }\n          const resultModel: Option[] = [\n            option({\n              id: \"test_1\",\n              name: \"HIV Test 1 (Determine)\",\n              category: \"HIV\",\n              shortName: \"Determine\",\n              lotNo: getLotNo(KitProp.DETERMINE),\n              expiryDate: getExpiryDate(KitProp.DETERMINE),\n              concept: \"Test 1\",\n              obs: (v: Option) =>\n                service.buildValueCoded(v.other.concept, v.value),\n            }),\n            option({\n              id: \"test_2\",\n              name: \"HIV Test 2 (Unigold)\",\n              category: \"HIV\",\n              disabled: true,\n              accessPoint: \"Health Facility\",\n              shortName: \"Unigold\",\n              concept: \"Test 2\",\n              lotNo: getLotNo(KitProp.UNIGOLD),\n              expiryDate: getExpiryDate(KitProp.UNIGOLD),\n              obs: (v: Option) =>\n                service.buildValueCoded(v.other.concept, v.value),\n            }),\n            option({\n              id: \"test_1_repeat\",\n              name: \"HIV Test 1 (Determine) Repeat\",\n              category: \"HIV\",\n              disabled: true,\n              shortName: \"Determine (Repeat)\",\n              accessPoint: \"Health Facility\",\n              concept: \"Immediate Repeat Test 1 Result\",\n              lotNo: getLotNo(KitProp.DETERMINE),\n              expiryDate: getExpiryDate(KitProp.DETERMINE),\n              obs: (v: Option) =>\n                service.buildValueCoded(v.other.concept, v.value),\n            }),\n            option({\n              id: \"test_3\",\n              name: \"HIV Test 3 (Bioline)\",\n              category: \"HIV\",\n              disabled: true,\n              shortName: \"Bioline\",\n              accessPoint: \"Health Facility\",\n              concept: \"Test 3\",\n              lotNo: getLotNo(KitProp.BIOLINE),\n              expiryDate: getExpiryDate(KitProp.BIOLINE),\n              obs: (v: Option) =>\n                service.buildValueCoded(v.other.concept, v.value),\n            }),\n            option({\n              id: 'syphilis',\n              name: \"Syphilis Test Result\",\n              category: \"Syphilis\",\n              shortName: \"Syphilis\",\n              concept: \"Syphilis Test Result\",\n              lotNo: getLotNo(KitProp.SYPHILIS),\n              expiryDate: getExpiryDate(KitProp.SYPHILIS),\n              obs: (v: Option) =>\n                service.buildValueCoded(v.other.concept, v.value),\n            }),\n            option({\n              id: 'hepatitis',\n              name: \"Hepatitis B Test Result\",\n              category: \"Hepatitis B\",\n              shortName: \"Hepatitis B\",\n              concept: \"Hepatitis B Test Result\",        \n              lotNo: getLotNo(KitProp.HEPATITIS),\n              expiryDate: getExpiryDate(KitProp.HEPATITIS),\n              obs: (v: Option) =>\n                service.buildValueCoded(v.other.concept, v.value),\n            }),\n          ];\n          const accessPoint = f.accesspoint_type.value;\n          const prevResults = Array.isArray(f.test_results)\n            ? f.test_results\n            : [];\n          // Merge previous entered results to default result model\n          const results: Option[] = resultModel.reduce(\n            (all: any, defaultOption: Option) => {\n              const existingResult = find(prevResults, {\n                label: defaultOption.label,\n              });\n              if (existingResult) {\n                if (\n                  existingResult.other.accessPoint != \"*\" &&\n                  existingResult.other.accessPoint != accessPoint\n                ) {\n                  existingResult.value = \"\";\n                }\n                all.push(existingResult);\n              } else {\n                all.push(defaultOption);\n              }\n              return all;\n            },\n            [] as Option[]\n          );\n          // Filter options by selected tests offered and access point field values\n          return f.tests_offered.reduce((all: Option[], c: Option) => {\n            const options: Option[] = results.filter(\n              (r: Option) =>\n                r.other.category === c.value &&\n                (r.other.accessPoint === accessPoint ||\n                  r.other.accessPoint === \"*\")\n            );\n            return options.length ? all.concat(options) : all;\n          }, []);\n        },\n      };\n    }\n    \n    function hivResultHiddenField(): Field {\n      let result = \"\";\n      return {\n        id: \"hiv_result\",\n        helpText: \"HIV Result\",\n        type: FieldType.TT_HIDDEN,\n        appearInSummary: () => false,\n        condition: (f: any) => testOffered(f, \"HIV\"),\n        onload: (f: any) => {\n          let hasLastTestPerfomed = f.last_hiv_perfomed != null;\n          let hasLastHivResult = f.last_hiv_result != null;\n          let testOneResult = \"\";\n          let testTwoResult = \"\";\n          let testThreeResult = \"\";\n          let testOneRepeat = \"\";\n          const testResults = (f.test_results||[]);\n          const isCommunity = f.accesspoint_type.value === \"Community\";\n          const lastHIVResult = () => f.last_hiv_result?.value;\n          const lastTestPerfomed = () => f.last_hiv_perfomed?.value;\n          testResults.forEach((r: Option) => {\n            switch (r.other.id) {\n              case \"test_1\":\n                testOneResult = r.value as string;\n                break;\n              case \"test_2\":\n                testTwoResult = r.value as string;\n                break;\n              case \"test_3\":\n                testThreeResult = r.value as string;\n                break;\n              case \"test_1_repeat\":\n                testOneRepeat = r.value as string;\n                break;\n            }\n          });\n          const inconclusiveNegativeForPreviousPositiveProfessional = () =>\n            hasLastHivResult &&\n            hasLastTestPerfomed &&\n            lastHIVResult() === \"Positive\" &&\n            lastTestPerfomed() === \"Professional\" &&\n            (testOneResult === \"Negative\" ||\n              testTwoResult === \"Negative\" ||\n              testThreeResult === \"Negative\");\n          const results: any = {\n            // TODO: Replace \"Incomplete\" with \"Testing not completed\"\n            Incomplete: () => [\n              f.accesspoint_type.value != \"Community\",\n              threeTierHIVtestNotComplete(testResults)\n            ],\n            Negative: () => [\n              !inconclusiveNegativeForPreviousPositiveProfessional(),\n              testOneResult === \"Negative\" ||\n                testTwoResult === \"Negative\" ||\n                testThreeResult === \"Negative\" ||\n                testOneRepeat === \"Negative\",\n            ],\n            Positive: () => [!isCommunity, testThreeResult === \"Positive\"],\n            Inconclusive: () => [\n              !isCommunity,\n              inconclusiveNegativeForPreviousPositiveProfessional() ||\n                (testTwoResult === \"Negative\" &&\n                  testOneRepeat === \"Positive\") ||\n                (testTwoResult === \"Positive\" &&\n                  testThreeResult === \"Negative\"),\n            ],\n            \"Positive Initial Professional\": () => [\n              isCommunity,\n              testOneResult === \"Positive\",\n            ],\n          };\n          result = Object.keys(results).reduce((finalResult: any, key: any) => {\n            if (results[key]().every(Boolean)) return key;\n            return finalResult;\n          }, \"Not indicated\");\n        },\n        defaultValue: () => {\n          if (result) return toOption(result);\n        },\n        finalComputedValue: () => {\n          if (result) {\n            const concept = \"HIV status\"\n            return {\n              offlineMeta: { [concept]: result },\n              obs: service.buildValueCoded(concept, result),\n            };\n          }\n        },\n      };\n    }\n\n    function hivPatientCategoryField(): Field {\n      let hivStatusCategory = \"N/A\";\n      return {\n        id: \"patient_category\",\n        helpText: \"Result given to client\",\n        type: FieldType.TT_HIDDEN,\n        onload: (f: any) => {\n          if (!f.hiv_result) return;\n          const newHivStatus = f.hiv_result.value;\n          const clientAge = htsClient.age;\n          const lastHivResult = f.last_hiv_result.value;\n          const lastTypeOfTestPerformed =\n            f.last_hiv_perfomed != null ? f.last_hiv_perfomed.value : \"\";\n          const lastTimeHivTestedInMonths =\n            f.last_time_hiv_tested != null\n              ? f.last_time_hiv_tested.other.monthsAgoInt\n              : -1;\n\n          const hivCategoryRef: Record<string, boolean[]> = {\n            \"New Positive\": [\n              newHivStatus === \"Positive\",\n              /never tested|negative|exposed|inconclusive/i.test(lastHivResult) ||\n                (lastHivResult === \"Positive\" &&\n                  /initial professional|self/i.test(lastTypeOfTestPerformed) &&\n                  lastTimeHivTestedInMonths <= 12),\n            ],\n            \"New exposed infant\": [\n              clientAge <= 0,\n              newHivStatus === \"Positive\",\n            ],\n            \"Positive Re-test\": [\n              newHivStatus === \"Positive\",\n              lastHivResult === \"Positive\",\n              lastTypeOfTestPerformed === \"Professional\"\n            ],\n            \"Inconclusive Re-test\": [\n              lastHivResult === \"Positive\",\n              newHivStatus === \"Inconclusive\",\n              lastTypeOfTestPerformed === \"Professional\"\n            ],\n            \"New Negative\": [\n              newHivStatus === \"Negative\"\n            ],\n            \"New Inconclusive\": [\n              newHivStatus === \"Inconclusive\",\n              (/self/i.test(lastTypeOfTestPerformed) && /invalid/i.test(lastHivResult)) ||\n              /never tested|negative|exposed infant/i.test(lastHivResult) ||\n                (lastHivResult === \"Positive\" &&\n                  /self|initial professional/i.test(lastTypeOfTestPerformed)),\n            ],\n          };\n          hivStatusCategory = Object.keys(hivCategoryRef).reduce(\n            (status: string, key: string) =>\n              hivCategoryRef[key].every(Boolean) ? key : status,\n            \"N/A\"\n          );\n        },\n        defaultValue: () => {\n          if (hivStatusCategory != \"N/A\")\n            return toOption(hivStatusCategory);\n        },\n        finalComputedValue: () => {\n          if (hivStatusCategory != \"N/A\") {\n            const concept = \"HIV group\"\n            return {\n              offlineMeta: { [concept]: hivStatusCategory },\n              obs: service.buildValueCoded(concept, hivStatusCategory),\n            };\n          }\n        },\n        condition: (f: any) => f.hiv_result.value,\n      };\n    }\n\n    return {\n      fields,\n      onFinish,\n      patientDashboardUrl\n    }\n  }\n});\n","import { render } from \"./HtsTesting.vue?vue&type=template&id=47886b88&ts=true\"\nimport script from \"./HtsTesting.vue?vue&type=script&lang=ts\"\nexport * from \"./HtsTesting.vue?vue&type=script&lang=ts\"\n\nimport exportComponent from \"/home/andrew-dev/Projects/HIS-Core/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { resolveDynamicComponent as _resolveDynamicComponent, openBlock as _openBlock, createBlock as _createBlock } from \"vue\"\n\nexport function render(_ctx: any,_cache: any,$props: any,$setup: any,$data: any,$options: any) {\n  return (_openBlock(), _createBlock(_resolveDynamicComponent(_ctx.formType), {\n    fields: _ctx.fields,\n    skipSummary: _ctx.skipSummary,\n    activeField: _ctx.activeField,\n    cancelDestinationPath: _ctx.cancelDestinationPath,\n    onOnFinish: _ctx.onFinish,\n    onFinish: _ctx.onFinishAction,\n    onOnIndex: _ctx.onIndex\n  }, null, 40, [\"fields\", \"skipSummary\", \"activeField\", \"cancelDestinationPath\", \"onOnFinish\", \"onFinish\", \"onOnIndex\"]))\n}","\nimport TouchScreenForm from \"@/components/Forms/TouchScreenForm.vue\";\nimport { defineComponent, PropType } from \"vue\";\nimport { Field } from \"./FieldInterface\";\n\nexport default defineComponent({\n    name: \"HisStandardForm\",\n    components: { TouchScreenForm },\n    emits: [\n        'onFinish',\n        'onIndex'\n    ],\n    data: () => ({\n        formType: 'touch-screen-form' as string\n    }),\n    props: {\n        onFinishAction: {\n            type: Function\n        },\n        skipSummary: {\n            type: Boolean,\n            default: false\n        },\n        activeField: {\n            type: String\n        },\n        fields: {\n            type: Object as PropType<Field[]>,\n            required: true\n        },\n        cancelDestinationPath: {\n            type: String,\n            required: false,\n        }\n    },\n    methods: {\n        onFinish(formData: any, computedData: any) {\n            this.$emit('onFinish', formData, computedData)\n        },\n        onIndex(i: number) {\n            this.$emit('onIndex', i)\n        }\n    }\n})\n","import { render } from \"./HisStandardForm.vue?vue&type=template&id=6daa0375&ts=true\"\nimport script from \"./HisStandardForm.vue?vue&type=script&lang=ts\"\nexport * from \"./HisStandardForm.vue?vue&type=script&lang=ts\"\n\nimport exportComponent from \"/home/andrew-dev/Projects/HIS-Core/node_modules/vue-loader-v16/dist/exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render]])\n\nexport default __exports__","import { Service } from \"@/services/service\";\nimport { find, isEmpty } from \"lodash\";\nimport { ref } from \"vue\";\nimport UserProp from \"@/composables/userproperty\"\n\nexport enum KitProp {\n    TEST_KIT_USER_PROPERTY = 'hts_user_assigned_kits',\n    HIV_SELF_KIT = 'HIV self-kit',\n    SYPHILIS = 'Syphilis',\n    HEPATITIS = 'Hepatitis B',\n    BIOLINE = 'Bioline',\n    DETERMINE = 'Determine',\n    UNIGOLD = 'Unigold'\n}\n\nexport function TestKit() {\n    const kits = ref<any>([])\n    const { getUserProp, setUserProp } = UserProp()\n\n    const getSelectedTests = async () => {\n        try {\n            const req = await getUserProp('HTS_PROGRAMS')\n            return `${req||''}`.split(',').map((prop: string) => prop.trim())\n        } catch (e) {\n            console.error(`${e}`)\n        }\n        return []\n    }\n\n    const initKits = async () => {\n        const defaultKits = [\n            {\n                kitName: KitProp.UNIGOLD,\n                lotNo: '',\n                expiryDate: '',\n                testGroup: 'profession_hiv_kit',\n                visible: true,\n                userProp: \"HIV Test\"\n            },\n            {\n                kitName: KitProp.DETERMINE,\n                lotNo: '',\n                expiryDate: '',\n                testGroup: 'profession_hiv_kit',\n                visible: true,\n                userProp: \"HIV Test\"\n            },\n            {\n                kitName: KitProp.BIOLINE,\n                lotNo: '',\n                expiryDate: '',\n                testGroup: 'profession_hiv_kit',\n                visible: true,\n                userProp: \"HIV Test\"\n            },\n            {\n                kitName: KitProp.HIV_SELF_KIT,\n                lotNo: '',\n                expiryDate: '',\n                visible: true\n            },\n            {\n                kitName: KitProp.SYPHILIS,\n                lotNo: '',\n                expiryDate: '',\n                visible: true,\n                userProp: \"Syphilis Test\"\n            },\n            {\n                kitName: KitProp.HEPATITIS,\n                lotNo: '',\n                expiryDate: '',\n                visible: true,\n                userProp: \"Hepatitis B Test\"\n            }\n        ]\n        try {\n            const selectedKits = await getSelectedTests()\n            const req: any = await getUserProp(KitProp.TEST_KIT_USER_PROPERTY)\n            const prevKits = JSON.parse(req||'')\n\n            defaultKits.forEach((kit: any) => {\n                if (kit.userProp && !isEmpty(selectedKits)) {\n                    kit.visible = selectedKits.includes(kit.userProp)\n                }\n                const preset = find(prevKits, { kitName: kit.kitName })\n                if (preset) {\n                    kit.lotNo = preset.lotNo\n                    kit.expiryDate = preset.expiryDate\n                }\n            })\n            kits.value = defaultKits.filter((k: any) => k.visible)\n        } catch (e) {\n            kits.value = defaultKits\n            console.error(`${e}`)\n        }\n        \n    }\n\n    const getLotNo = (kitName: KitProp) => {\n        const data = find(kits.value, { kitName })\n        if (data) {\n            if(new Date(data.expiryDate) <= new Date(Service.getSessionDate())) {\n                return ''\n            }\n            return data.lotNo\n        } \n        return ''\n    }\n\n    const getExpiryDate = (kitName: KitProp) => {\n        const date = find(kits.value, { kitName })\n        if (date) {\n            if (new Date(date.expiryDate) <= new Date(Service.getSessionDate())) {\n                return ''\n            }\n            return date.expiryDate\n        }\n        return ''\n    }\n\n    const saveKits = () => setUserProp(KitProp.TEST_KIT_USER_PROPERTY, JSON.stringify(kits.value))\n\n    return {\n        kits,\n        initKits,\n        saveKits,\n        getLotNo,\n        getExpiryDate\n    }\n}\n"],"sourceRoot":""}